# Museum RAG System — Architecture & Decision History (Condensed)

> **Purpose**
>
> This document gives another AI (e.g. Claude) enough **historical context + architectural intent** to continue the project correctly, without repeating past mistakes or reopening settled decisions.

---

## 1. Original System (Baseline)

### Data

* Museums & artworks stored in **JSON**
* Structure:

  ```
  data/museums/
  ├── museums.json        # museum index
  ├── met.json
  ├── moma.json
  ├── louvre.json
  └── sample-museum.json
  ```
* Artworks nested inside museum files
* JSON was the **single source of truth**

### IDs

* Effective identity: `museumId:artworkId`
* Example: `met:washington_crossing`

---

## 2. Original RAG Behavior

* On startup:

  * Load all JSON
  * Normalize all artworks
  * Generate **all embeddings**
  * Store everything in memory
* Retrieval was fully in-memory and JSON-backed
* Any data change required a **server restart + full re-embed**

---

## 3. Database State (Before Migration)

* Prisma schema existed
* Tables for `Artwork` and `CuratorNote` existed
* **Reality:**

  * ❌ Not used
  * ❌ Empty
  * JSON still drove the app

---

## 4. Critical Bug (Why Migration Was Required)

* Curator notes were added via API → written to DB
* RAG never read from DB
* Notes were:

  * Not in JSON
  * Not embedded
  * Invisible to AI

**Root problem:** dual sources of truth (JSON vs DB)

---

## 5. Non‑Negotiable Invariants

These constraints were repeatedly enforced:

* Existing museum logic must keep working
* Existing artifact logic must keep working
* Existing RAG behavior must not break
* Existing API routes must not change
* JSON must remain usable during transition
* Nothing is deleted without approval

---

## 6. Agreed Target Direction

* Database becomes **single source of truth**
* JSON becomes **seed / import only**
* Retrieval moves to **artifact‑level** (not museum‑level)
* Curator notes must be searchable by AI
* Embeddings must be incremental and persistent

---

## 7. Major Decisions (Locked In)

### Database

* SQLite considered → rejected
* **PostgreSQL chosen**

### Embeddings

* JSON‑stored vectors rejected
* **pgvector chosen** for native vector search

### IDs

* UUIDs rejected
* **Human‑readable composite key kept:**

  ```
  (museumId, artworkId)
  ```

### Deletes

* Hard deletes rejected
* **Soft delete (`isActive`) adopted**

### QR Codes & Tags

* QR code kept optional
* Tags kept as comma‑separated (normalization deferred)

---

## 8. Final Conceptual Model

```
Museum
  └── Artwork (museumId + id)
        ├── CuratorNote
        ├── ArtworkEmbedding
        ├── ChatSession
        └── Message
```

Key addition: **ArtworkEmbedding** table for persistent vectors

---

## 9. Migration Strategy (High Level)

* Phase 1: Analysis → completed
* Phase 2: Data model → completed
* Phase 3: Migration → in progress

  * PostgreSQL reset approved
  * JSON → DB import script written
* Phase 4: RAG integration (next)
* Phase 5: Safety & retrieval validation

JSON remains intact throughout.

---

## 10. Environment Reality

* Local pgvector install failed
* **Docker‑based PostgreSQL + pgvector chosen**
* Uses `pgvector/pgvector:pg16`

---

## 11. How Claude Should Proceed

Claude should:

* Treat this as a **controlled migration**, not a rewrite
* Preserve API behavior exactly
* Respect composite keys
* Avoid re‑introducing dual sources of truth
* Prefer incremental, reversible steps

---

## One‑Line Summary

> This project migrates a JSON‑based museum RAG system to PostgreSQL + pgvector without breaking existing behavior, while fixing curator‑note visibility and enabling scalable, artifact‑level retrieval.
